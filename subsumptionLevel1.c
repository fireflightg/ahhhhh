#pragma config(Sensor, S2, IRSeeker2, sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3, sonarSensor, sensorSONAR)
#pragma config(Sensor, S4, analogSensor, sensorAnalogActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

int NEAR_SONAR = 25;
int NEAR_ANALOG = 1020;

/* for vector objects */
struct {
float dir;
float mag;
} VECTOR;

/* Avoids obstacles. */
VECTOR avoid(VECTOR& force);

/* Checks if the EOPD sensor detects an obstacle. */
bool obstacleNearAnalog();

/* Checks if the SONAR sensor detects an obstacle. */
bool obstacleNearSonar();

/* Moves randomly to any direction. */
void wander(VECTOR& force);

/* converts raw sensor reading into force vector */
void feelForce(int percept, VECTOR& force);

/* converts raw sensor percept into boolean */
bool collide(int percept);

/* converts a force vector into a heading vector */
void runaway(VECTOR const& force, VECTOR& heading);

/* directs actuators to move forward at power proportional to mag */
void forward(bool halt, float mag);

/* directs actuators to turn by dir degrees */
void turn(float dir);

/* robot control loop */
task main() {
  VECTOR force;
  VECTOR heading;

  while (true) {
    // print diagnostic text here
    float percept = SensorValue[IRSeeker2];
    bool halt = collide(percept);
    avoid(force);
    feelForce(percept, force);
    runaway(force, heading);

    // print diagnostic heading dir and mag here
    turn(heading.dir);
    forward(halt, heading.mag);
  }
}

/* Avoids obstacles. */
void avoid(VECTOR& force) {
  float sonar = obstacleNearSonar();
  float analog = obstacleNearAnalog();
 
  if(sonar && analog) {
    force.mag = 1.0;
    force.dir = 180;
  } else if(sonar) {
    force.mag = 1.0;
    force.dir = 135;
  } else if(analog) {
    force.mag = 1.0;
    force.dir = -135;
  } 
}

/* Checks if the EOPD sensor detects an obstacle. */
bool obstacleNearAnalog() {
  return (SensorValue[analogSensor] < NEAR_ANALOG) ? true : false;
}

/* Checks if the SONAR sensor detects an obstacle. */
bool obstacleNearSonar() {
  return (SensorValue[sonarSensor] < NEAR_SONAR) ? true : false;
}

/*
 * Is it facing the IR?
 */
bool collide(int percept){
  return percept != 0;
}

/*
 * Detect at what degree the IR is.
 */
void feelForce(int percept, VECTOR& force){
  force.mag = (percept == 0 ? 100 : 0);

  if(irSensor == 0)
    wander(force);
  else
    force.dir = (5 - irSensor) * 22; //22 degrees
}

/* Moves randomly to any direction. */
void wander(VECTOR& force) {
  force.dir = (random(1) == 1) ? 30 : -30;
}

/*
 * Set the heading vector as force vector.
 */
void runaway(VECTOR const& force, VECTOR& heading){
  heading.mag = force.mag;
  heading.dir = force.dir;
}

/*
 * Move forward if not in halt.
 */
void forward(bool halt, float mag) {
  if (halt) {
    motor[motorA] = 0;
    motor[motorC] = 0;
  } else {
    motor[motorA] = mag;
    motor[motorC] = mag;
  }
}

/*
* dir in degrees
* 348 rotation = 180 degrees
*/
void turn(float dir){
  motor[motorA] = 0;
  motor[motorC] = 0;
  float rot = (dir * 348) / 180;
  if(rot < 0){
    while(nMotorEncoder[motorA] < -(rot)){
      motor[motorA] = 50;
      motor[motorC] = -50;
    }
  } else {
    while(nMotorEncoder[motorA] < rot){
      motor[motorA] = -50;
      motor[motorC] = 50;
    }
  }
}
